From 15f8dd05b4ad5ddf4756c2e26ec3bb033d3234b5 Mon Sep 17 00:00:00 2001
From: David Huff <dhuff@redhat.com>
Date: Thu, 10 Jul 2008 17:15:31 -0400
Subject: [PATCH] added compat shims for old api

---
 imgcreate/fs.py |  201 +-----------------------------------------------------
 1 files changed, 4 insertions(+), 197 deletions(-)

diff --git a/imgcreate/fs.py b/imgcreate/fs.py
index 5d94018..d8c6731 100644
--- a/imgcreate/fs.py
+++ b/imgcreate/fs.py
@@ -92,211 +92,21 @@ class BindChrootMount:
 #===============================================================================
 class LoopbackMount:
     def __init__(self, lofile, mountdir, fstype = None):
-        self.lofile = lofile
-        self.mountdir = mountdir
-        self.fstype = fstype
-
-        self.mounted = False
-        self.losetup = False
-        self.rmdir   = False
-        self.loopdev = None
-
-    def cleanup(self):
-        self.unmount()
-        self.lounsetup()
-
-    def unmount(self):
-        if self.mounted:
-            rc = subprocess.call(["/bin/umount", self.mountdir])
-            if rc == 0:
-                self.mounted = False
-
-        if self.rmdir and not self.mounted:
-            try:
-                os.rmdir(self.mountdir)
-            except OSError, e:
-                pass
-            self.rmdir = False
-
-    def lounsetup(self):
-        if self.losetup:
-            rc = subprocess.call(["/sbin/losetup", "-d", self.loopdev])
-            self.losetup = False
-            self.loopdev = None
-
-    def loopsetup(self):
-        if self.losetup:
-            return
-
-        losetupProc = subprocess.Popen(["/sbin/losetup", "-f"],
-                                       stdout=subprocess.PIPE)
-        losetupOutput = losetupProc.communicate()[0]
-
-        if losetupProc.returncode:
-            raise MountError("Failed to allocate loop device for '%s'" %
-                             self.lofile)
-
-        self.loopdev = losetupOutput.split()[0]
-
-        rc = subprocess.call(["/sbin/losetup", self.loopdev, self.lofile])
-        if rc != 0:
-            raise MountError("Failed to allocate loop device for '%s'" %
-                             self.lofile)
-
-        self.losetup = True
-
-    def mount(self):
-        if self.mounted:
-            return
-
-        self.loopsetup()
-
-        if not os.path.isdir(self.mountdir):
-            os.makedirs(self.mountdir)
-            self.rmdir = True
-
-        args = [ "/bin/mount", self.loopdev, self.mountdir ]
-        if self.fstype:
-            args.extend(["-t", self.fstype])
-
-        rc = subprocess.call(args)
-        if rc != 0:
-            raise MountError("Failed to mount '%s' to '%s'" %
-                             (self.loopdev, self.mountdir))
-
-        self.mounted = True
+        DiskMount.__init__(LoopbackDisk(lofile,size = 0),mountdir,fstype,rmmountdir = True)
 
 #===============================================================================
 # SparseLoopbackMount  compatibility layer for old API
 #===============================================================================
 class SparseLoopbackMount(LoopbackMount):
     def __init__(self, lofile, mountdir, size, fstype = None):
-        LoopbackMount.__init__(self, lofile, mountdir, fstype)
-        self.size = size
-
-    def expand(self, create = False, size = None):
-        flags = os.O_WRONLY
-        if create:
-            flags |= os.O_CREAT
-            makedirs(os.path.dirname(self.lofile))
-
-        if size is None:
-            size = self.size
-
-        fd = os.open(self.lofile, flags)
-
-        os.lseek(fd, size, 0)
-        os.write(fd, '\x00')
-        os.close(fd)
-
-    def truncate(self, size = None):
-        if size is None:
-            size = self.size
-        fd = os.open(self.lofile, os.O_WRONLY)
-        os.ftruncate(fd, size)
-        os.close(fd)
-
-    def create(self):
-        self.expand(create = True)
+        DiskMount.__init__(SparseLoopbackDisk(lofile,size),mountdir,fstype,rmmountdir = True)
 
 #===============================================================================
 # SparseExtLoopbackMount  compatibility layer for old API
 #===============================================================================
 class SparseExtLoopbackMount(SparseLoopbackMount):
     def __init__(self, lofile, mountdir, size, fstype, blocksize, fslabel):
-        SparseLoopbackMount.__init__(self, lofile, mountdir, size, fstype)
-        self.blocksize = blocksize
-        self.fslabel = fslabel
-
-    def __format_filesystem(self):
-        rc = subprocess.call(["/sbin/mkfs." + self.fstype,
-                              "-F", "-L", self.fslabel,
-                              "-m", "1", "-b", str(self.blocksize),
-                              self.lofile,
-                              str(self.size / self.blocksize)])
-        if rc != 0:
-            raise MountError("Error creating %s filesystem" % (self.fstype,))
-        subprocess.call(["/sbin/tune2fs", "-c0", "-i0", "-Odir_index",
-                         "-ouser_xattr,acl", self.lofile])
-
-    def create(self):
-        SparseLoopbackMount.create(self)
-        self.__format_filesystem()
-
-    def resize(self, size = None):
-        current_size = os.stat(self.lofile)[stat.ST_SIZE]
-
-        if size is None:
-            size = self.size
-
-        if size == current_size:
-            return
-
-        if size > current_size:
-            self.expand(size)
-
-        self.__fsck()
-
-        resize2fs(self.lofile, size)
-
-        if size < current_size:
-            self.truncate(size)
-        return size
-
-    def mount(self):
-        if not os.path.isfile(self.lofile):
-            self.create()
-        else:
-            self.resize()
-        return SparseLoopbackMount.mount(self)
-
-    def __fsck(self):
-        subprocess.call(["/sbin/e2fsck", "-f", "-y", self.lofile])
-
-    def __get_size_from_filesystem(self):
-        def parse_field(output, field):
-            for line in output.split("\n"):
-                if line.startswith(field + ":"):
-                    return line[len(field) + 1:].strip()
-
-            raise KeyError("Failed to find field '%s' in output" % field)
-
-        dev_null = os.open("/dev/null", os.O_WRONLY)
-        try:
-            out = subprocess.Popen(['/sbin/dumpe2fs', '-h', self.lofile],
-                                   stdout = subprocess.PIPE,
-                                   stderr = dev_null).communicate()[0]
-        finally:
-            os.close(dev_null)
-
-        return int(parse_field(out, "Block count")) * self.blocksize
-
-    def __resize_to_minimal(self):
-        self.__fsck()
-
-        #
-        # Use a binary search to find the minimal size
-        # we can resize the image to
-        #
-        bot = 0
-        top = self.__get_size_from_filesystem()
-        while top != (bot + 1):
-            t = bot + ((top - bot) / 2)
-
-            if not resize2fs(self.lofile, t):
-                top = t
-            else:
-                bot = t
-        return top
-
-    def resparse(self, size = None):
-        self.cleanup()
-        
-        minsize = self.__resize_to_minimal()
-
-        self.truncate(minsize)
-        self.resize(size)
-        return minsize
+        ExtDiskMount.__init__(SparseLoopbackDisk(lofile,size), mountdir, fstype, blocksize, fslabel, rmmountdir = True)
 
 #===============================================================================
 # Disk
@@ -347,7 +157,6 @@ class Disk:
         return self._size
     size = property(get_size)
 
-
 class RawDisk(Disk):
     def __init__(self, size, device):
         Disk.__init__(self, size, device)
@@ -396,9 +205,7 @@ class LoopbackDisk(Disk):
         logging.debug("Losetup remove %s" % self.device)
         rc = subprocess.call(["/sbin/losetup", "-d", self.device])
         self.device = None
-
-
-
+              
 class SparseLoopbackDisk(LoopbackDisk):
     def __init__(self, lofile, size):
         LoopbackDisk.__init__(self, lofile, size)
-- 
1.5.4.1

